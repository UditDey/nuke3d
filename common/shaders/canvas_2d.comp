#version 460

// Specialization constants, these _must_ be overridden
// Constant ID 0: Workgroup size
layout(local_size_x_id = 0, local_size_y_id = 0) in;

// Constant ID 1: Sample count
// Actual number of samples is this value squared, max value is 5
layout(constant_id = 1) const uint NUM_SAMPLES = 0;

// Constant ID 2: Size of boundary element buffers in bytes
layout(constant_id = 2) const uint BOUNDARY_ELEM_BUF_SIZE = 0;

// Boundary element definitions
struct Line {
    vec2 c_a;
    vec2 c_b;
};

const uint SIZE_OF_LINE = 16;

// Shader inputs/outputs
// Boundary elements metadata
layout(push_constant) uniform readonly Metadata {
    uint num_lines;
} metadata;

// Line elements
layout(set = 0, binding = 0) uniform readonly LinesBuffer {
    Line lines[BOUNDARY_ELEM_BUF_SIZE / SIZE_OF_LINE];
} lines_buf;

// Output image
layout(set = 1, binding = 0, rgba32f) uniform writeonly image2D image;

// This pixel's coordinates
vec2 pixel_coord = vec2(gl_WorkGroupID.xy * gl_WorkGroupSize.x + gl_LocalInvocationID.xy);

// This pixel's sample bitmap
uint samples = 0;

// Process a line's contribution
void proc_line(in Line line) {
    float delta = 1.0 / float(NUM_SAMPLES);
    uint mask = 1 << 1;

    vec2 sample_point = pixel_coord;

    for(uint i = 0; i < NUM_SAMPLES; i++) {
        for(uint j = 0; j < NUM_SAMPLES; j++) {
            Line trans_line;
            trans_line.c_a = line.c_a - sample_point;
            trans_line.c_b = line.c_b - sample_point;

            float t = trans_line.c_a.y / (trans_line.c_a.y - trans_line.c_b.y);
            float s = (1 - t) * trans_line.c_a.x + t * trans_line.c_b.x;

            if(s > 0.0 && t > 0.0 && t < 1.0) {
                samples ^= mask;
            }

            mask <<= 1;
            sample_point.x += delta;
        }

        mask <<= 1;
        sample_point.x = pixel_coord.x;
        sample_point.y += delta;
    }
}

void main() {    
    // Process lines
    for(uint i = 0; i < metadata.num_lines; i++) {
        proc_line(lines_buf.lines[i]);
    }

    // Calculate the pixel's luma
    float luma = float(bitCount(samples)) / float((NUM_SAMPLES * NUM_SAMPLES));

    imageStore(image, ivec2(pixel_coord), luma * vec4(1.0));
}